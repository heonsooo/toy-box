# TS

JS 기반 해커뉴스 프로젝트를 TS로 포팅하는 프로젝트.
- JS와 TS의 차이점과 코드 상에서 유용한 기능을 얻을 수 있을지. 
- TS로는 조금의 설정, 셋업이 필요하다. 각각의 설정들에 대해서 이 설정들이 무엇인지 살펴보기
- TS로 프로젝트를 진행하기 위해서는 tsconfig.json 파일 설정 필요 (여기서는 가장 기본적인 옵션만 설정)
- TS의 가장 핵심정인 기능은 JS의 타입 확장 구문을 제공하는 것.

``` json
{
  "compilerOptions": {
    "strict": true,    // 타입스크립트의 기능을 얼마나 엄격하게 적용해서 변환할 것인지 (false이면 js파일 그대로도 사용이 가능하다. = 소프트랜딩할 수 있게 도와줌)
    "target": "ES5",    // 타입스크립트를 컴파일하면 JS파일이 나오는데 해당 JS파일에 사용 될 문법 체계를 지정 
    "module": "CommonJS",
    "alwaysStrict": true,
    "noImplicitAny": true,   // strict 모드의 하위 옵션으로 모든 타입(Any)이 가능 한지(JS의 느슨한 타입을 받아들이기 위해)설정하는 옵션 -> Any 타입 허락안해서 모든 타입 명시해야함.
    "noImplicitThis": true,  // 
    "sourceMap": true,       // 개발환경과 실해환경을 일치시킬 수 있는 설정 
    "downlevelIteration": true
  }
}
```
- html파일 1개와 순수 js파일 1개로 해커뉴스 웹을 만들었는데, 이는 parcel.js라는 번들러가 다른 환경설정 없이 모던 웹 개발이 가능하도록 만들어주는 기능으로 가능했다.
- 커멘드창에 parcel index.html 를 입력해서 타입스크립트 컴파일
- parcel이 type script를 불러서 컴파일한다.


## 변수에 대한 타입지정
- 자바스크립트의 암묵적인 타입 지정 -> 타입스크립트의 명시적인 타입 지원 기능을 통한 타입 지정
- 할당된 변수 오른쪽에 마우스를 올리면 타입을 보여준다. 
- 변수 : 타입 = 할당 식 으로 작성.
- 타입 알리아스 ( type 알리아스명(일반적으로 파스칼표기법 사용))


# 타입스크립트의 타입 지정하는 두 가지 방법
1. 타입 알리아스
2. 인터페이스 
두 가지 방법은 문법적으로 아주 조금 차이가 있다.
제공 되는 기능은 거의 유사하며, 작은 몇 가지 차이가 있다.

-> 선언부 지정
-> 타입 결합/조합 방법

## 타입 알리아스를 사용한 타입 지정
1. type 변수명 = { ... } 으로 지정
```typescript
type milk = {
  a : number
}
```

2. 타입 결합/조합 방법 : & 사용
```typescript
type milk = {
  a : number
}
type coffee =  milk & {
  // milk를 확장해서 새로운 타입 
  b : number
}
```

## 인터페이스를 사용한 타입 지정
- 수학 연산보다는, 글로써 표현하는 듯한 기법으로 인해, 확장되는 형식의 타입들은 인터페이스를 선호한다.
1. interface 변수명 {} 으로 지정
```typescript
interface milk {
  a : number
}
```
2. 타입 결합/조합 방법 : extends 사용
```typescript
interface milk {
  a : number
}
interface coffee extends milk {
  // milk를 확장해서 새로운 타입 
  b : number
}
```

3. 지시어를 통해 타입에 대한 설명을 덧붙일 수 있다.
- 단단하고 안전한 코드 작성 가능해짐.
```typescript
interface student {
  readonly id : string
}
// student 객체의 id는 readonly 지시어를 통해 수정 불가능하도록 지정 가능.
```

## [TS특징]
- 타입스크립트는 트랜스 파일러이기 때문에 브라우저에서 실행시키기 위해서는 자바스크립트로 변환 시켜야 한다. 
- 자바스크립트로 변환하는 과정에서 여러 옵션을 설정할 수 있다.
- 타입스크립트에서 자바스크립트로 변환하는 과정은 컴파일이라고 부르고 tsconfig.json파일에서 설정하여 사용한다.
- tsconfig.json은 옵션이 굉장히 많다.
  - 참고 : https://www.typescriptlang.org/ko/docs/handbook/tsconfig-json.html 
- 타입에 대한 설명을 풍성하게 많이 해 놓을 수록 코딩을 하며 실수할 수 있는 부분을 미연에 방지하여 단단하고 안전한 코드를 작성할 수 있다.
- 처음 타입을 작성할 때 많은 시간을 투자하면, 이후 실제 코드 작성에 있어서는 고민을 줄여 시간을 단축시킬 수 있다.
  -> 수정해도 되는지/안되는지 고민하는 시간을 절약할 수 있기 때문에!


## CH04_05. 상속과 믹스인
- 중복 된 코드는 함수로 묶어서 하나로 만들고 필요할 때마다 호출해서 재사용 하는 식으로 중복 된 코드를 제거하는 기법을 사용한다.
- 규모가 커지다 보면, 중복된 코드는 계속 반복되고 단순한 함수로 묵어서는 온전히 다 제거하기는 쉽지 않을 것이다.
  -> 함수 자체가 무한정으로 늘어날 수 있고 늘어나는 함수들의 이름을 정해주기도 쉽지 않아질 것이다.
- 따라서 코드를 작성함에 있어서 목적에 부합하는 범주를 정하고 해당 범주로 묶어 분류하며 의미를 더 잘 부여할 수 있게 중복된 코드를 제거하는 기법이 있다.

### "상속"
- 공통 요소를 만들어 넣고, 공통 요소를 확장할 수 있는 개별 요소들을 만드는 방법.
  -> 타입 알리아스를 사용해서 공통 요소를 사용해서 부모 타입 알리아스에 넣고 
  -> 개별 요소들은 부모 타입 알리아스로부터 확장해서 사용한다.
- 상속을 사용하는 방법은 크게 **클래스**를 사용하는 방법과 **믹스인**을 사용하는 방법이 있다.
- 클래스는 extends를 이용해서 부모를 상속받아서 사용한다.
- 믹스인은 클래스를 이용해서 구현하지만, extends를 이용하지 않고 클래스를 함수 혹은 객체처럼 바라보고 필요한 경우마다 class를 **합성**해서 새로운 기능으로 확장해 나간다.
- 믹스인 기법은 class 자체를 훨씬 더 독립적인 주체로 바라보기 때문에 상/하위 관계로 묘사되지 않는다.

그렇다면 클래스 상속이 아닌 믹스인을 사용하는 이유는 ? 
1. 기존 extends 방식은 코드에 적시되어야 하는 상속 방법이다.
  -> 상속의 관계를 바꾸기 위해서는 코드 자체를 바꿔야한다.
  -> 따라서 관계를 유연하게 가져갈 수 없다. (추상화)
2. 자바스크립트, 타입스크립트에서는 다중 상속을 지원하지 않는다.
  -> extends로는 여러개의 클래스를 상속받을 수 없기 때문에 

믹스인 기법은 코드로 만들어놓은 테크닉이기 때문에 위 2가지가 가능하다. (상위 클래스 n개를 받을 수 있다!)

## CH04_06 뷰 쿨래스로 코드 구조 개선 
- 함수로 되어 있는 코드를 모두 클래스로 바꾸는 작업.
- 공통된 목적(UI업데이트 , 보조적 기능 ) 함수를 추출하여 클래스로 변환
- 함수보다 더 추상적으로 사용 가능 ? (인스턴스에 필요한 정보**만**저장 해 두었다가 필요한 경우에 계속 재활용해서 쓸 수 있다는 장점으로 쓰기 때문에 하나의 동작을 모두 하는 함수보다는 생성자에 조금 더 공통적인(꼭 필요한) 부분만 남겨둔다.)
- [함수->클래스]인스턴스를 처음 만들 때만 필요한 코드만 남겨두고 나머지 코드는 해당하는 목적의 메소드로 분류한다.
- 상위클래스를 상속 받으면, 생성자함수에서 상위 클래스를 명시적으로 super()을 이용해 호출해 주어야 한다.
-  


[클래스_작성_방법]
- 첫 글자를 대문자로 명시하는 컨벤션따르기 

- 클래스 선언 후 생성자 만들기
  - 생성자에서 하는 역할 : 인스턴스 생성 시 발생하는 동작들
  - 인스턴스에 필요한 정말 필요한 공통적인 기능만을 선언하기.  
  - 나머지 코드들은 해당 목적에 맞는 메소드로 분류 후 사용하기
- 클래스에서 변수, 타입을 선언하면, 생성자함수에서 반드시 초기화를 해주어야 한다.
- 상위 클래스에 공통 요소를 뽑아내면 뽑아낼 수록 자식 클래스에서 할 일이 적어지기 때문에 좋다.
- 클래스를 상속 받을 때, extends로 확장 후 super()을 생성자함수에 선언한다.

- 클래스를 만든다는 의미 = 인스턴스를 만든다 = 인스턴스에 필요한 정보들을 저장해 두었다가 필요한 경우에 계속 재활용해서 쓰는 것.

- 속성 접근자
  - private : 외부/자식에서도 접근 불가 
  - protected : 외부에서 접근 불가 / 자식에서 접근 가능 
  - 
```javascript
class MakeParentsClass{
  testString : string ;   // #2  변수 선언 후 초기화
  constructor(){          // #1  클래스 선언 후 생성자 함수
    this.testString = ''  // #2  변수 선언 후 초기화
  }

}
class MakeChildClass extends MakeParentsClass{
  constructor(){

  }

}
```


## CH04_07 파일의 분리, 더욱 성잘할 앱을 위한 준비
- 코드를 분리해서 깔끔하고 관리하기 쉬운 형태의 프로젝트를 만드는 방법 
  - 구조를 개선하기 위해 디렉토리를 만들고, 분산시키고 배치시킨다.
  - 디렉토리 생성 : src 
  - app.ts파일에는 다양한 역할의 코드들이 모여있다.
    -> [공통코드] view, router, api 코드    : src/core 폴더
    -> [UI] 페이지와 관련된 클래스           : src/page
    -> [인터페이스]                         : src/types
-  코드들이 여러 파일에 나누어져 분산되었을 때는 코드를 불러야 사용할 수 있음.
   -> 자바스크립트의 module 스펙을 이용해 해당 기능 수행.
   -> module 스펙은 import/export 구문 
    -> import 다른 파일에 있는 코드를 가져오는 문법
    -> export 해당 파일의 코드를 import 해갈 수 있게 허락해주는 문법
  ->  class 지시어 앞에 export를 붙이면 외부에서 import 해갈 수 있다.
  해당 파일에서 1개 / 여러개를 export할 수 있다.
  -> export default : default를 붙여주면, 기본으로 가져가겠다는 의미. 여러 export 중에 하나만 default로 지정해서도 사용 가능하다.


## CH04_08 안전한 전역 상태관리
- app.ts에 있는 store 객체를 store.ts 파일에 클래스로 분리하여 만든다.
- 이제 전역변수를 지우고 store class를 인스턴스로 만들어 사용하는 클래스에 전달하면 된다.
- 하지만 이렇게 하면 store를 안전하게 관리하기 어렵다. 왜냐하면 외부 다른 class 코드에서 직접적으로 store 값을 제어하기 때문이다.
- 이를 방어하기 위해 
  - -> 1. 아예 외부에 노출시키지 않는다. (private 선언)
  - -> 2. store 클래스가 값을 읽고 쓰는 메소드 기능을 제공한다. (getter/setter)


## CH04_09 XHR to Fetch & Promise (비동기 통신)
- 동기코드로 작성하면, api를 호출하고 나서 응답을 받을 때 까지 UI가 끊기거나 멈춰있는 현상이 있다.
- 따라서 많은 api를 연동하게 되면 당연히 비동기 코드로 작성해야 한다.
- 비동기 처리를 작성하는 방법은 이벤트 시스템을 사용하는 것이다. 
- ajax open 후 이벤트 리스너(addEventListner)를 등록하여 콜백 처리 
- fetch api는 XHR 자체가 여러가지 단점을 많이 갖고 있어 보완재로 나온 XHR을 대응하는 api 이다. 최신 버전 모던 브라우저에서 모두 지원하며 promise 베이스 api이다.
- promise 객체가 제공하는 then 메소드를 이용해서 비동기 함수를 계속 연결해서 붙여 기존 뎁스가 계속 깊어지는 XHR의 콜백 지옥을 일자로 펼칠 수 있는 코드 구조로 만들 수 있다.
- 기본적으로 Promise도 콜백 구조이기는 하지만 콜백 뎁스를 깊은 뎁스로 만들지 않고 하나의 뎁스로 일자로 펼 수 있는 구조를 제공하는 특징이 있다.
-  promise 객체가 제공하는 then 메소드를 이용해서 비동기 함수를 계속 연결해서 붙여 기존 뎁스가 계속 깊어지는 XHR의 콜백 지옥을 일자로 펼칠 수 있는 코드 구조로 만들 수 있다.
- then 에서는 JSON 데이터 가오면 JSON 데이터를 비동기적으로 객체로 바꿔주는 기능 제공 ★★
    -> 응답 값을 받아서 받은 값에 .json 메소드 붙여주면 비동기적으로 객체 변환시켜줌.
    -> JSON.parse 는 동기적으로 작동 -> 데이터가 크면 UI가 멈추는 현상


### fetch Api 
- fetch api는 XHR 자체가 여러가지 단점을 많이 갖고 있어 보완재로 나온 XHR을 대응하는 api 이다.
-  최신 버전 모던 브라우저에서 모두 지원하며 promise 베이스 api이다.
-  기본적으로 Promise도 콜백 구조이기는 하지만 콜백 뎁스를 깊은 뎁스로 만들지 않고 하나의 뎁스로 일자로 펼 수 있는 구조를 제공하는 특징이 있다.


[Memo]
- 개발에 있어 코드를 읽기 쉽게 작성하기 위해서 **일관성**을 유지하는 것이 중요한 가치 중 하나이다.
- 클래스의 경우, 인스턴스를 만들고 시작해야하기 때문에 파스칼 케이스로 작성하는 컨벤션이 있다.
- 전역공간에 전역변수를 선언한 다는 것은 편리하지만 불안한 공간이다. 왜냐하면, 잘못된 데이터를 세팅 / 오버라이트 하면 어플리케이션이 제대로 동작하지 않는 등 심각한 문제가 발생할 수 있다. 규모가 커지면 어디서 잘못 되었는지 찾는게 굉장히 어렵기 때문이다. 따라서 모두가 접근 가능한 전역 공간은 가능한 사용하지 않는게 좋다.

[Do]
- parcel.js 란 ?